# Sobre os bugs apresentados e suas correções

## A solução apresentada não efetua o último movimento necessário

A descrição deste bug é um pouco enganadora. O último disco no pino de origem não era movido e a torre era considerada como solucionada. Isso acontecia por causa de uma checagem em `Domain.TorreHanoi.TorreHanoi.Resolver(int numeroDiscosRestante, Pino origem, Pino intermediario, Pino destino)`:


    if (numeroDiscosRestante <= 1)
    {
        return;
    }

Como `numeroDiscosRestante` corresponde diretamente ao numero de discos que deve ser movido do pino de origem para o pino de destino, a checagem ignorava o ultimo disco no pino de origem. A correção é bem simples:


    if (numeroDiscosRestante <= 0)
    {
        return;
    }


## A API não retorna a imagem do estado atual de uma execução

Neste caso, a descrição é bem literal. O erro se encontrava em `Application.TorreHanoi.Implementation.TorreHanoiApplicationService.ObterImagemProcessoPor(string id)`:

    var torre = _domainService.ObterPor(new Guid());

O parametro `id` não era passado para o metodo de serviço. Em vez disso um Guid vazio era passado. A correção novamente foi bem simples:

    var torre = _domainService.ObterPor(new Guid(id));

## A imagem gerada para visualização da torre não leva em consideração o tamanho dos discos utilizados.

Este não era um dos bugs iniciais mas algo que notei enquanto testava a correção para o bug anterior. Quantidades de discos acima de 5 geram discos largos o bastante para sobrepor discos em outros pinos. Isso acontece porque o espaçamento entre os pinos é constante enquanto a largura dos discos é definida por

    var larguraDoDisco = disco.Id * _larguraPadrao;

Como este não é um dos bugs originais (e pode estar fora de escopo para o projeto), ele não foi corrigido. Soluções possiveis incluem: 

- Escalar a distancia entre pinos (e portanto o tamanho da imagem) com o numero de discos.
- Utilizar um modelo aditivo para a largura adicional (`var larguraDoDisco = disco.Id * _ajuste + _larguraPadrao;` onde `_ajuste` é a difença em pixels na largura de dois discos sequenciais). Esta solução permite manter o tamanho da imagem para uma quantidade maior de discos, mas exibira o mesmo problema da solução atual eventualmente.
- Escalar o tamanho das representações com o numero de discos. Esta solução permite torres de tamanho arbitrário mas tem legibilidade reduzida para torres maiores.


# Sobre os testes unitários.

Além dos testes para os bugs mencionados, um terceiro teste falha: `Tests.TorreHanoi.Domain.TorreHanoiUnit.Construtor_Deve_Retornar_Sucesso()`. Este teste também foi implementado.

